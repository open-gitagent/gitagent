import { existsSync, readFileSync, readdirSync } from 'node:fs';
import { join, resolve } from 'node:path';
import yaml from 'js-yaml';
import { loadAgentManifest, loadFileIfExists } from '../utils/loader.js';
import { loadAllSkills, getAllowedTools } from '../utils/skill-loader.js';

export function exportToOpenAI(dir: string): string {
  const agentDir = resolve(dir);
  const manifest = loadAgentManifest(agentDir);

  // Build system prompt
  const systemPrompt = buildSystemPrompt(agentDir, manifest);

  // Build tools array
  const tools = buildToolDefinitions(agentDir, manifest);

  // Generate Python code for OpenAI Agents SDK
  const lines: string[] = [];

  lines.push('"""');
  lines.push(`OpenAI Agents SDK definition for ${manifest.name} v${manifest.version}`);
  lines.push(`Generated by gitagent export`);
  lines.push('"""\n');

  lines.push('from agents import Agent, Tool\n');

  // Tool definitions
  if (tools.length > 0) {
    for (const tool of tools) {
      const funcName = tool.name.replace(/-/g, '_');
      lines.push(`def ${funcName}(${tool.params}):`);
      lines.push(`    """${tool.description}"""`);
      lines.push(`    # TODO: Implement tool logic`);
      lines.push(`    pass\n`);
    }
  }

  // Agent definition
  lines.push(`${manifest.name.replace(/-/g, '_')}_agent = Agent(`);
  lines.push(`    name="${manifest.name}",`);
  lines.push(`    instructions="""${systemPrompt.replace(/"""/g, '\\"\\"\\"')}""",`);

  if (manifest.model?.preferred) {
    lines.push(`    model="${manifest.model.preferred}",`);
  }

  if (tools.length > 0) {
    const toolNames = tools.map(t => t.name.replace(/-/g, '_'));
    lines.push(`    tools=[${toolNames.join(', ')}],`);
  }

  lines.push(`)\n`);

  return lines.join('\n');
}

function buildSystemPrompt(agentDir: string, manifest: ReturnType<typeof loadAgentManifest>): string {
  const parts: string[] = [];

  const soul = loadFileIfExists(join(agentDir, 'SOUL.md'));
  if (soul) parts.push(soul);

  const rules = loadFileIfExists(join(agentDir, 'RULES.md'));
  if (rules) parts.push(rules);

  // Skills â€” loaded via skill-loader
  const skillsDir = join(agentDir, 'skills');
  const skills = loadAllSkills(skillsDir);
  for (const skill of skills) {
    const toolsList = getAllowedTools(skill.frontmatter);
    const toolsNote = toolsList.length > 0 ? `\nAllowed tools: ${toolsList.join(', ')}` : '';
    parts.push(`## Skill: ${skill.frontmatter.name}\n${skill.frontmatter.description}${toolsNote}\n\n${skill.instructions}`);
  }

  // Check for agents/openai.yaml MCP dependencies
  const openaiConfigPath = join(agentDir, 'agents', 'openai.yaml');
  if (existsSync(openaiConfigPath)) {
    const openaiConfig = yaml.load(readFileSync(openaiConfigPath, 'utf-8')) as Record<string, unknown>;
    if (openaiConfig && typeof openaiConfig === 'object') {
      parts.push(`## OpenAI Agent Configuration\n${yaml.dump(openaiConfig)}`);
    }
  }

  if (manifest.compliance) {
    const c = manifest.compliance;
    const constraints: string[] = ['## Compliance Constraints'];
    if (c.communications?.fair_balanced) constraints.push('- All outputs must be fair and balanced');
    if (c.communications?.no_misleading) constraints.push('- Never make misleading statements');
    if (c.data_governance?.pii_handling === 'redact') constraints.push('- Redact all PII');
    if (c.supervision?.human_in_the_loop === 'always') constraints.push('- All decisions require human approval');
    if (constraints.length > 1) parts.push(constraints.join('\n'));
  }

  return parts.join('\n\n');
}

interface ToolDef {
  name: string;
  description: string;
  params: string;
}

function buildToolDefinitions(agentDir: string, manifest: ReturnType<typeof loadAgentManifest>): ToolDef[] {
  const tools: ToolDef[] = [];
  const toolsDir = join(agentDir, 'tools');

  if (!existsSync(toolsDir)) return tools;

  const files = readdirSync(toolsDir).filter(f => f.endsWith('.yaml'));

  for (const file of files) {
    const content = readFileSync(join(toolsDir, file), 'utf-8');
    const toolConfig = yaml.load(content) as {
      name: string;
      description: string;
      input_schema?: {
        properties?: Record<string, { type: string }>;
        required?: string[];
      };
    };

    const params: string[] = [];
    if (toolConfig.input_schema?.properties) {
      for (const [name, schema] of Object.entries(toolConfig.input_schema.properties)) {
        const pyType = jsonTypeToPython(schema.type);
        const isRequired = toolConfig.input_schema.required?.includes(name);
        if (isRequired) {
          params.push(`${name}: ${pyType}`);
        } else {
          params.push(`${name}: ${pyType} = None`);
        }
      }
    }

    tools.push({
      name: toolConfig.name,
      description: toolConfig.description,
      params: params.join(', '),
    });
  }

  return tools;
}

function jsonTypeToPython(jsonType: string): string {
  switch (jsonType) {
    case 'string': return 'str';
    case 'integer': return 'int';
    case 'number': return 'float';
    case 'boolean': return 'bool';
    case 'array': return 'list';
    case 'object': return 'dict';
    default: return 'str';
  }
}
